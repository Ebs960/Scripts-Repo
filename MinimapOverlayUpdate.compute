#pragma kernel UpdateTiles

StructuredBuffer<int> _TilePixelIndices;
StructuredBuffer<int> _TilePixelOffsets;
StructuredBuffer<int> _TilePixelCounts;
StructuredBuffer<float4> _TileColors;
StructuredBuffer<int> _Owners; // -1 = neutral
StructuredBuffer<int> _Fog;    // 0 hidden,1 explored,2 visible
StructuredBuffer<int> _DirtyTiles;
StructuredBuffer<float4> _OwnerColors;

RWTexture2D<float4> _Result;

int _Width;
int _DirtyCount;
float _OwnershipBlend;
int _OwnershipMode; // 0 = blend, 1 = replace
int _ApplyOwnership;
int _ApplyFog;
int _OwnerColorCount;

[numthreads(64,1,1)]
void UpdateTiles (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _DirtyCount) return;
    int tile = _DirtyTiles[id.x];
    if (tile < 0) return;

    // Base color
    float4 baseCol = _TileColors[tile];

    // Ownership tint
    if (_ApplyOwnership == 1)
    {
        int owner = _Owners[tile];
        if (owner >= 0 && owner < _OwnerColorCount)
        {
            float4 ocol = _OwnerColors[owner];
            if (_OwnershipMode == 0)
            {
                baseCol.rgb = lerp(baseCol.rgb, ocol.rgb, _OwnershipBlend);
            }
            else
            {
                baseCol.rgb = ocol.rgb;
            }
        }
    }

    // Fog
    if (_ApplyFog == 1)
    {
        int fog = _Fog[tile];
        if (fog == 0)
        {
            baseCol = float4(0,0,0,1);
        }
        else if (fog == 1)
        {
            float gray = dot(baseCol.rgb, float3(0.299, 0.587, 0.114));
            baseCol.rgb = (gray * 0.6).xxx;
        }
        // fog==2 keep as is
    }

    int offset = _TilePixelOffsets[tile];
    int count  = _TilePixelCounts[tile];
    for (int i = 0; i < count; i++)
    {
        int pix = _TilePixelIndices[offset + i];
        int y = pix / _Width;
        int x = pix - y * _Width;
        _Result[int2(x,y)] = baseCol;
    }
}
